Help on module pype:

NAME
    pype - Infix programming toolkit

FILE
    /home/mandark/home/code/python/pype/pype.py

DESCRIPTION
    Module enablig an infix syntax, as an exemple,
    resolving the 2nd Euler Project exercise:
    "Find the sum of all the even-valued terms in Fibonacci
     which do not exceed four million."
    
    euler2 = fib() | where(lambda x: x % 2 == 0)
                   | take_while(lambda x: x < 4000000)
                   | add
    
    The basic symtax is to use a Pipe like in a shell :
    >>> [1, 2, 3] | add
    6
    
    Each FuncPipe is a function acting like a Pipe, for exemple where :
    >>> [1, 2, 3] | where(lambda x: x % 2 == 0) #doctest: +ELLIPSIS
    <generator object <genexpr> at ...>
    
    A FuncPipe is nothing more than a function returning a specialized Pipe,
    
    You can construct your pipes using Pipe and FuncPipe classes like :
    
    stdout = Pipe(lambda x: sys.stdout.write(str(x)))
    select = FuncPipe(lambda iterable, pred: (pred(x) for x in iterable))
    
    Or using decorators :
    @Pipe
    def stdout(x):
        sys.stdout.write(str(x))
    
    
    stdout
        Outputs anything to the standard output
        >>> "42" | stdout
        42
    
    lineout
        Outputs anything to the standard output followed by a line break
        >>> 42 | lineout
        42
    
    concat()
        Aggregates strings using given separator, or ", " by default
        >>> [1, 2, 3, 4] | concat()
        '1, 2, 3, 4'
    
    average
        Returns the average of the given iterable
        >>> [1, 2, 3, 4, 5, 6] | average
        3.5
    
    count
        Returns the length of the given iterable, counting elements one by one
        >>> [1, 2, 3, 4, 5, 6] | count
        6
    
    add
        Returns the sum of all elements in the preceding iterable
        >>> (1, 2, 3, 4, 5, 6) | add
        21
    
    first
        Returns the first element of the given iterable
        >>> (1, 2, 3, 4, 5, 6) | first
        1
    
    chain
        Unfold preceding Iterable of Iterables
        >>> [[1, 2], [3, 4], [5]] | chain | concat()
        '1, 2, 3, 4, 5'
    
      Warning : chain only unfold iterable containing ONLY iterables :
          [1, 2, [3]] | chain
              Gives a TypeError: chain argument #1 must support iteration
              Consider using traverse
    
    traverse
        Recursively unfold iterables
        >>> [[1, 2], [[[3], [[4]]], [5]]] | traverse | concat()
        '1, 2, 3, 4, 5'
    
    select()
        Apply a conversion expression given as parameter
        to each element of the given iterable
        >>> [1, 2, 3] | select(lambda x: x * x) | concat()
        '1, 4, 9'
    
    where()
        Only yields the matching items of the given iterable
        >>> [1, 2, 3] | where(lambda x: x % 2 == 0) | concat()
        '2'
    
    take_while()
        Like itertools.takewhile, yields elements of the
        given iterable while the predicat is true
        >>> [1, 2, 3, 4] | take_while(lambda x: x < 3) | concat()
        '1, 2'
    
    skip_while()
        Like itertools.dropwhile, skips elements of the given iterable
        while the predicat is true, then yields others
        >>> [1, 2, 3, 4] | skip_while(lambda x: x < 3) | concat()
        '3, 4'
    
    chain_with()
        Like itertools.chain, yields elements of the given iterable,
        then yields elements of its parameters
        >>> (1, 2, 3) | chain_with([4, 5], [6]) | concat()
        '1, 2, 3, 4, 5, 6'
    
    take()
        Yields the given quantity of elemenets from the given iterable
        >>> (1, 2, 3, 4, 5) | take(2) | concat()
        '1, 2'
    
    skip()
        Skips the given quantity of elements from the given iterable, then yields
        >>> (1, 2, 3, 4, 5) | skip(2) | concat()
        '3, 4, 5'
    
    islice()
        Just the itertools.islice
        >>> (1, 2, 3, 4, 5, 6, 7, 8, 9) | islice(2, 8, 2) | concat()
        '3, 5, 7'
    
    izip()
        Just the itertools.izip
        >>> (1, 2, 3, 4, 5, 6, 7, 8, 9)             | izip([9, 8, 7, 6, 5, 4, 3, 2, 1])             | concat()
        '(1, 9), (2, 8), (3, 7), (4, 6), (5, 5), (6, 4), (7, 3), (8, 2), (9, 1)'
    
    aggregate()
        Works as python reduce
        >>> (1, 2, 3, 4, 5, 6, 7, 8, 9) | aggregate(lambda x, y: x * y)
        362880
    
        >>> (1, 2, 3, 4, 5, 6, 7, 8, 9)             | aggregate(lambda x, y: str(x) + ', ' + str(y))
        '1, 2, 3, 4, 5, 6, 7, 8, 9'
    
    any()
        Returns True if any element of the given iterable satisfies the predicate
        >>> (1, 3, 5, 6, 7) | any(lambda x: x >= 7)
        True
    
        >>> (1, 3, 5, 6, 7) | any(lambda x: x > 7)
        False
    
    
    all()
        Returns True if all elements of the given iterable
        satisfies the given predicate
        >>> (1, 3, 5, 6, 7) | all(lambda x: x < 7)
        False
    
        >>> (1, 3, 5, 6, 7) | all(lambda x: x <= 7)
        True
    
    max()
        Returns the biggest element, using the given comparator
        >>> ('a', 'foo', 'qwerty', 'bar') | max(lambda x, y: len(x) - len(y))
        'qwerty'
    
    groupby()
        Like itertools.groupby(sorted(iterable, key = keyfunc), keyfunc)
        (1, 2, 3, 4, 5, 6, 7, 8, 9)             | groupby(lambda x: x % 2 and "Even" or "Odd")
                | select(lambda x: "%s : %s" % (x[0], (x[1] | concat(', '))))
                | concat(' / ')
        'Even : 1, 3, 5, 7, 9 / Odd : 2, 4, 6, 8'
    
    permutations()
        Returns all possible permutations
        >>> 'ABC' | permutations(2) | concat(' ')
        "('A', 'B') ('A', 'C') ('B', 'A') ('B', 'C') ('C', 'A') ('C', 'B')"
    
        >>> range(3) | permutations() | concat('-')
        '(0, 1, 2)-(0, 2, 1)-(1, 0, 2)-(1, 2, 0)-(2, 0, 1)-(2, 1, 0)'
    
    Euler project samples :
    
        # Find the sum of all the multiples of 3 or 5 below 1000.
        euler1 = (itertools.count() | select(lambda x: x * 3) | take_while(lambda x: x < 1000) | add)            + (itertools.count() | select(lambda x: x * 5) | take_while(lambda x: x < 1000) | add)            - (itertools.count() | select(lambda x: x * 15) | take_while(lambda x: x < 1000) | add)
        assert euler1 == 233168
    
        # Find the sum of all the even-valued terms in Fibonacci which do not exceed four million.
        euler2 = fib() | where(lambda x: x % 2 == 0) | take_while(lambda x: x < 4000000) | add
        assert euler2 == 4613732
    
        # Find the difference between the sum of the squares of the first one hundred natural numbers and the square of the sum.
        square = lambda x: x * x
        euler6 = square(itertools.count(1) | take(100) | add) - (itertools.count(1) | take(100) | select(square) | add)
        assert euler6 == 25164150

CLASSES
    FuncPipe
    Pipe
    
    class FuncPipe
     |  Represent a Pipeable Function :
     |  It's a function returning a Pipe
     |  Described as :
     |  select = FuncPipe(lambda iterable, pred: (pred(x) for x in iterable))
     |  and used as :
     |  print [1, 2, 3] | select(lambda x: x * 2)
     |  # 2, 4, 6
     |  
     |  Methods defined here:
     |  
     |  __call__(self, *value)
     |  
     |  __init__(self, function)
    
    class Pipe
     |  Represent a Pipeable Element :
     |  Described as :
     |  first = Pipe(lambda iterable: iter(iterable).next())
     |  and used as :
     |  print [1, 2, 3] | first
     |  printing 1
     |  
     |  Methods defined here:
     |  
     |  __init__(self, function)
     |  
     |  __ror__(self, other)

DATA
    __author__ = 'Julien Palard <julien@eeple.fr>'
    __credits__ = 'Jerome Schneider, for its Python skillz'
    __date__ = '26 Aug 2010'
    __version__ = '1.2'
    add = <pype.Pipe instance>
    aggregate = <pype.FuncPipe instance>
    all = <pype.FuncPipe instance>
    any = <pype.FuncPipe instance>
    average = <pype.Pipe instance>
    chain = <pype.Pipe instance>
    chain_with = <pype.FuncPipe instance>
    concat = <pype.FuncPipe instance>
    count = <pype.Pipe instance>
    first = <pype.Pipe instance>
    groupby = <pype.FuncPipe instance>
    islice = <pype.FuncPipe instance>
    izip = <pype.FuncPipe instance>
    lineout = <pype.Pipe instance>
    max = <pype.FuncPipe instance>
    netcat = <pype.FuncPipe instance>
    permutations = <pype.FuncPipe instance>
    select = <pype.FuncPipe instance>
    skip = <pype.FuncPipe instance>
    skip_while = <pype.FuncPipe instance>
    stdout = <pype.Pipe instance>
    take = <pype.FuncPipe instance>
    take_while = <pype.FuncPipe instance>
    traverse = <pype.Pipe instance>
    where = <pype.FuncPipe instance>

VERSION
    1.2

DATE
    26 Aug 2010

AUTHOR
    Julien Palard <julien@eeple.fr>

CREDITS
    Jerome Schneider, for its Python skillz


